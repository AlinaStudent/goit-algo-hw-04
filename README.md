# goit-algo-hw-04

## Структура
- `task_1.py` — рекурсивне копіювання/переміщення файлів з сортуванням за розширеннями.
- `koch_snowflake.py` — візуалізація фракталу «сніжинка Коха» з налаштовуваним рівнем рекурсії.
- `sorting_benchmark.py` — бенчмарк Insertion, Merge та Timsort (вбудоване `sorted`) з `timeit`.

---

Завдання 1

виконано:
1. Парсинг аргументів: `source_dir` (обов’язково), `dest_dir` (необов’язково, за замовчуванням `dist`), додаткові прапори `--move`, `--create-test`, `--print-tree`, `-v/--verbose`.
2. Рекурсивний обхід директорій у `iter_files_recursively()`.
3. Копіювання/переміщення файлів у піддиректорії, названі за розширенням (`txt`, `py`, `no_extension`, ...).
4. Обробка винятків та перевірка шляхів.
5. Після виконання: усі файли з вихідної теки рекурсивно потрапляють у директорію призначення, розсортовані за розширеннями.

Приклади запуску:
```bash
# створити тестові дані + показати "ялинку"
python task_1.py --create-test --print-tree

# копіювати з власної теки у dist
python task_1.py /path/to/src --print-tree

# копіювати з src у вказану теку
python task_1.py /path/to/src /path/to/dest --print-tree

# переміщати (не копіювати)
python task_1.py --move /path/to/src /path/to/dest



## Завдання 3

Що зроблено: емпіричний бенчмарк Insertion, Merge і Timsort (sorted) з timeit на різних наборах (random, sorted, reverse, nearly_sorted, many_duplicates). Є також секція емпіричного масштабування (як змінюється час при зростанні n).

python sorting_benchmark.py
python sorting_benchmark.py --sizes 2000,10000,40000 --repeat 5 --number 1 --ins-max 20000
python sorting_benchmark.py --no-scaling

висновки:

Insertion sort
На малих масивах і майже відсортованих даних швидкий, але загалом масштабування O(n²) → при подвоєнні n час ≈ ×4.
На середніх/великих n непридатний.

Merge sort
Стабільно O(n log n) на будь-яких розподілах; зазвичай значно швидший за Insertion на n ≥ кілька тисяч.
Потребує додаткової пам’яті O(n), не адаптивний до локальної впорядкованості.

Timsort (вбудовані sorted/.sort)
Гібрид: поєднує вставки для малих «пробігів» і ефективне злиття, адаптивний (використовує існуючі впорядковані фрагменти, добре працює з дублікатами).
На випадкових/зворотних даних працює на рівні або швидше за Merge; на майже відсортованих — значно швидше.

Висновок: у реальних задачах Timsort переважає (саме тому Python використовує його за замовчуванням), і програмісти зазвичай користуються вбудованими алгоритмами, а не пишуть власні.

Емпіричне підтвердження теорії:
Insertion: квадратичне зростання (≈×4 при n → 2n).
Merge/Timsort: n log n (≈×2.2–×2.4 при n → 2n).
На nearly_sorted/many_duplicates Timsort демонструє додатковий виграш завдяки адаптивності.


